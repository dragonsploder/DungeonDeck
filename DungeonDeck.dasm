; Boilerplate
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
        
; Defines
bg_color 	= $8E
underline_color	= $00
sprite_height 	= $07
sprite_y 	= $40
sprite_x 	= $52
sprite 		= $14
cards_len 	= $08

deck_len	= 45
deck_len_hex	= $45
true_empty_card	= $9B
empty_card	= $8A
left_hand_card	= $5A
right_hand_card = $6A
backpack_card 	= $7A

sword_type	= $00
potion_type	= $10
sheild_type	= $20
enemy_type	= $30
player_type 	= $40

; Var
        seg.u variables
	org $80

; Main
framecounter 	byte
gamestate	byte
buttonstate	byte
joyupstate	byte
joydownstate	byte
switchrunstate  byte
score		byte
        
; Temporary storage
temp		byte
temp2 		byte
temp3 		byte

; Card data
cards		ds 9 ; Add zero support
cardindxt 	ds 9
cardindxn 	ds 9
cardindxc	ds 9
cardasprite 	ds 7
cardacolor	byte
cardbsprite 	ds 7
cardbcolor	byte
flashindex	byte

; Deck
deckindex	byte
deck		ds deck_len
cardsinplay	byte
cardsleft	byte

; Underline
underlineindex	byte

; Random Num Stuff
seed		ds 2

; Code 
	seg code
        org $F000

init
	CLEAN_START
        
        ; Init frame
        lda #$00
        sta framecounter
        sta gamestate
        sta buttonstate
        sta joyupstate
        sta joydownstate
        sta switchrunstate
        sta score
        
        lda #$09
        sta flashindex
  	
        ; Set seed
        lda #$73
        sta seed
        lda #$01
        sta seed+1
        
        jsr fill_deck
        jsr shuffle_deck
        jsr shuffle_deck
	
        ; Fill cards with data
        lda #empty_card
        sta cards+0
        sta cards+1
        sta cards+2
        sta cards+3
        
        ldy #deck_len_hex
        sty cardsleft		
        ldy #deck_len
        dey
        sty deckindex
        
        jsr new_room
        
        ; Fill empty card
        lda #true_empty_card
        sta cardindxt+8 
        sta cardindxn+8
        lda #bg_color
        sta cardindxc+8
                 
        ; Setup Player
        lda #$49
        sta cards+4
        lda #left_hand_card
        sta cards+5
        lda #right_hand_card
        sta cards+6
        lda #backpack_card
        sta cards+7
        
        ; Empty card
        lda #true_empty_card
        sta cards+8
        
        lda #$04
        sta cardsinplay
        
        ; Setup underline
        lda #%000110000
        sta NUSIZ0
        
        lda #$03
        sta underlineindex

new_frame
        lsr SWCHB	; test Game Reset switch
        bcc init	; reset?
        
        ; Check tv type switch
        lda SWCHB
        and #%00001000
        cmp #%00001000
        bne data_frame
        jmp normal_frame
data_frame       
        ; Print Score board
        VERTICAL_SYNC
        TIMER_SETUP 37
        TIMER_WAIT
        
        lda #$00
        sta VBLANK	; turn off VBLANK
        
        ldy #bg_color   ; load bg color
	sty COLUBK	; set bg color
        
        TIMER_SETUP 50
        
        TIMER_WAIT
        
        TIMER_SETUP 142

	lda #%00000010
        sta CTRLPF
        
        lda cardsleft
        and #$0F
        jsr mult5
        sta temp
        
        clc
        adc #$05
        tax

	ldy #$05
score_fill_loop
	dex
        dey
	lda score_bitmap,X
	sta cardasprite,Y
        cpx temp
        bne score_fill_loop
        
        lda cardsleft
        ;and #$F0
        lsr
        lsr
        lsr
        lsr
        jsr mult5
        sta temp
        
        clc
        adc #$05
        tax

	ldy #$05
score_fill_loop2
	dex
        dey
	lda score_bitmap,X
        asl
        asl
        asl
        asl
        ora cardasprite,Y
	sta cardasprite,Y
        cpx temp
        bne score_fill_loop2
        
        ldx #$05
score_loop
	dex
	ldy #$05
score_loop_small
        sta WSYNC
        lda cardasprite,X
        sta PF1
        lda #$00
        SLEEP 40
        sta PF1
        dey
        bne score_loop_small
        cpx #$00
	bne score_loop
	
        
        TIMER_WAIT
        
        
       	lda #2		
        sta VBLANK	; turn on VBLANK
        
        
	TIMER_SETUP 30	; Vblank
        TIMER_WAIT
        
        jmp new_frame
	
normal_frame
        
        VERTICAL_SYNC
        
        
        TIMER_SETUP 37  ; Vblank
        
        jsr fill_cards
        
        
        sta WSYNC	; Set sprite A position
        SLEEP 40	
        lda #$c0
        sta RESP0
        sta HMP0
        
        
        lda #$10
        sta HMM0
        sta WSYNC
        SLEEP 44
        sta RESM0
        sta WSYNC
        sta HMOVE
        
        
      	TIMER_WAIT	; End Vblank
        
        
        lda #$00
        sta VBLANK	; turn off VBLANK
        
        ldy #bg_color   ; load bg color
	sty COLUBK	; set bg color
        
        
        
        TIMER_SETUP 16  ; 20 scanlines before first card
        
        lda #$00
        jsr fill_card_a	; Fill A sprite with card 0 data
        
        TIMER_WAIT	; End 20 scanlines
        
	jsr print_card_a	; Print card 0
        			; Takes 8 scanlines
          
        TIMER_SETUP 21
        
        lda #$00
        cmp underlineindex
        bne skip_first_line
        sta WSYNC
        sta WSYNC
        jsr print_underline
skip_first_line
                                
        
        lda #$01
        jsr fill_card_a ; Fill A sprite with card 1 data
        
        lda #$02
        jsr fill_card_b ; Fill B sprite with card 2 data
        

        sta WSYNC	; Set card 1&2 position
        SLEEP 40
        lda #$30
        sta RESP0
        sta HMP0
        lda #$d0
        sta RESP1
        sta HMP1
        sta WSYNC
        SLEEP 70
        sta HMOVE
	
        
        TIMER_WAIT	; End 20 scanlines
        
	jsr print_card_ab	; Printcard 1&2
        			; Takes 8 scanlines
       	
        TIMER_SETUP 20
        
        lda #$01
        cmp underlineindex
        bne skip_second_line
        lda #$e0
        sta HMM0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        sta WSYNC
        jsr print_underline
skip_second_line
        
        lda #$02
        cmp underlineindex
        bne skip_third_line
        lda #$c0
        sta HMM0
        sta WSYNC
        SLEEP 50
        STA RESM0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        jsr print_underline
skip_third_line

        lda #$03
        jsr fill_card_a	; Fill A sprite with card 3 data
        
        lda #$d0
        sta WSYNC	; Set card 3 position
        SLEEP 45
        sta RESP0
        sta HMP0
        
        lda #$f0
        sta HMM0
        sta WSYNC
        SLEEP 46
        sta RESM0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        
        TIMER_WAIT	; End 20 scanlines
        
	jsr print_card_a	; Print card 3
        			; Takes 8 scanlines

	TIMER_SETUP 22

        lda #$03
        cmp underlineindex
        bne skip_fourth_line
        sta WSYNC
        sta WSYNC
        jsr print_underline
skip_fourth_line
        
        lda #$04
        jsr fill_card_a	; Fill A sprite with card 4 data
        
        
        TIMER_WAIT	; End 24 scanlines
        
	jsr print_card_a	; Print card 4
        			; Takes 8 scanlines
        
        
        TIMER_SETUP 21 	; 20 scanlines spacing
        
        lda #$04
        cmp underlineindex
        bne skip_fifth_line
        sta WSYNC
        sta WSYNC
        jsr print_underline
skip_fifth_line
        
        lda #$05
        jsr fill_card_a	; Fill Sprite A with card 5 data
        lda #$06
        jsr fill_card_b ; Fill Sprite B with card 6 data
        
        sta WSYNC	; Set card 5&6 position
        SLEEP 40
        lda #$30
        sta RESP0
        sta HMP0
        lda #$d0
        sta RESP1
        sta HMP1
        sta WSYNC
        SLEEP 70
        sta HMOVE
        
        	
        TIMER_WAIT	; End 14 scanlines
        
	jsr print_card_ab	; Print card 5&6
        
        TIMER_SETUP 20	; 20 scanlines spacing
        
        lda #$05
        cmp underlineindex
        bne skip_sixth_line
        lda #$00
        sta HMM0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        sta WSYNC
        jsr print_underline
skip_sixth_line

        lda #$06
        cmp underlineindex
        bne skip_seventh_line
        lda #$c0
        sta HMM0
        sta WSYNC
        SLEEP 50
        STA RESM0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        jsr print_underline
skip_seventh_line
        
        lda #$07
        jsr fill_card_a	; Fill Sprite A with card 7 data
        
        lda #$50
        sta HMM0
        sta WSYNC	; Set card 7 position
        SLEEP 43
        lda #$d0
        sta RESP0
        sta RESM0
        sta HMP0
        sta WSYNC
        SLEEP 70
        sta HMOVE
        
        
        TIMER_WAIT	; End 20 scanlines
        
        jsr print_card_a
        
        TIMER_SETUP 24	; 28 scanlines spacing
        
        lda #$07
        cmp underlineindex
        bne skip_eigth_line
        sta WSYNC
        sta WSYNC
        jsr print_underline
skip_eigth_line

	jsr do_joystick ; Do joystick stuff up here for time

        TIMER_WAIT	; End 28 scanlines

	
	lda #2		
        sta VBLANK	; turn on VBLANK
        
        
	TIMER_SETUP 30	; Vblank
        
        lda gamestate
        cmp #$03
        bne player_not_dead
 	jmp end_button
        
player_not_dead       
        ; Check Switches
        lda SWCHB
        and #%00000010
        cmp #%00000010
        beq reset_game_select
        lda switchrunstate
        cmp #$00
        bne skip_game_select
        lda cardsinplay
        cmp #$04
        bne skip_game_select
        ; Game Select Used as run
        ; Check if we can run
        
        
        ; Sub 2 hp
        lda cards+4
        and #$0F
        sec
        sbc #$02
        ; Do a branch for death check
        beq cont
        bpl cont0
cont
	jmp player_death
cont0
        ora #$40
        sta cards+4
        
        jsr put_cards_back
        jsr new_room
        
        
        lda #$01
        sta switchrunstate
 	jmp skip_game_select
        
reset_game_select
	lda #$00
        sta switchrunstate
        
skip_game_select
        
        
        

	lda INPT4
        and #$80
        beq cont1
        jmp no_push_button
cont1        
        lda buttonstate
        beq cont2
        jmp end_button
cont2
        
        lda #$01
        sta buttonstate
        
        lda gamestate
        bne skip_button_state_one
        
              
        ; GAME LOGIC
        
        ; STATE ZERO
        
        ldx underlineindex
        lda cards,X
        cmp #empty_card		; Can't grab empty card
        bne cont3 
        jmp end_button	
cont3        
        
        
        
        lda underlineindex
        sta flashindex
        lda #$01
        sta gamestate
        jmp end_button
        
        ; END STATE ZERO
        
        ; STATE ONE
        
skip_button_state_one
	
        lda flashindex
        cmp #$04
        bcc card_pick_sector_zero
        jmp card_pick_sector_one
        

card_pick_sector_zero
	
        
	lda underlineindex
        cmp #$04
        beq card_place_on_player
        
        cmp #$05
        beq card_place_on_left
        
        cmp #$06
        beq card_place_on_right
        
        cmp #$07
        beq card_place_on_back
        


	jmp card_pick_end_no_action
        
        
card_place_on_player
        ldy flashindex
        lda cards,Y
        and #$F0
        tax

	lda cards,Y
        and #$0F
        
        cpx #$30
        bne cont4
        ldx #empty_card
        stx cards,Y
        jsr count_card_usage
        jmp attack_player
cont4
	jmp card_pick_end_no_action
        

card_place_on_left
        lda cards+5
        cmp #left_hand_card
        beq check_monster_empty_card
        jmp check_shield_full_card
card_place_on_right
        lda cards+6
        cmp #right_hand_card
        beq check_monster_empty_card
        jmp check_shield_full_card
card_place_on_back
        lda cards+7
        cmp #backpack_card
        beq check_monster_empty_card
        jmp card_pick_end_no_action


check_monster_empty_card
	ldx flashindex
        lda cards,X
        and #$F0
        cmp #enemy_type
        ;beq card_pick_end_no_action
        bne cont5
        jmp card_pick_end_no_action
cont5
	jsr count_card_usage
        jmp card_place
        
	
check_shield_full_card		; Only case here is a monster on a sheild
	and #$F0
        cmp #sheild_type
        ;bne card_pick_end_no_action
        beq cont6
	jmp card_pick_end_no_action
cont6
        ldx flashindex
        lda cards,X
        and #$F0
        cmp #enemy_type
        ;bne card_pick_end_no_action
        beq cont7
	jmp card_pick_end_no_action
cont7

	; SHIELD BLOCK
        stx temp
        jsr count_card_usage
        ldx temp
        
        lda cards,X
        and #$0F
        sta temp		; Monster value
        ldy underlineindex
        lda cards,Y		; Shield value
        and #$0F
        sec
        sbc temp		; Shield - Monster
        bmi monster_attack	; Monster won
        beq monster_attack
        
        ora #sheild_type
        sta cards,Y
        
	lda #empty_card
        sta cards,X
        
        jmp card_pick_end_no_action

monster_attack
	sta temp
        lda #$00
        sec
        sbc temp
        sta temp

        jsr replace_hand_underline
        
        ldx flashindex
        lda #empty_card
        sta cards,X
        lda temp
        jmp attack_player
 
card_pick_sector_one
	
        ;lda underlineindex
        ;cmp #$04
        lda #$04
        cmp underlineindex
        bcc hand_card_swap ; Card placed back in sector one
        
        
        ldx flashindex
        lda cards,X
        and #$F0 		    ; Grab Card Type
        
        cmp #sword_type		    ; Only sword can be used in the case
        ;bne 
        beq cont8
        jmp card_pick_end_no_action
cont8        
        cpx #$07	            ; Cannot come from backpack
        ;beq 
        bne cont9
    	jmp card_pick_end_no_action 
cont9
                
        lda cards,X
        and #$0F
        sta temp
        
        ldy underlineindex
        lda cards,Y
        and #$F0
        cmp #$30
        ;bne 
        beq cont10 
        jmp card_pick_end_no_action  ; Must be placed on monster
cont10
        
        ; SWORD ATTACK
        
        lda cards,Y			; Get monster hp
        and #$0F
	
        sec
        sbc temp
        bmi monster_killed
        beq monster_killed
        
        clc
        adc #$30			; Remake monster card
        sta cards,Y
        
        ;jmp replace_hand
        jsr replace_hand_flash
        jmp card_pick_end_no_action
        
hand_card_swap
	ldx underlineindex
        lda cards,X
        and #$0F
        cmp #$0A
        ;bne 
        beq cont11
        jmp card_pick_end_no_action
cont11
        
        ldy flashindex
        lda cards,Y
        sta temp
        ; Potion check
        and #$F0
        cmp #$10
        beq potion_heal_sector_one
        lda temp
        
        
        sta cards,X
        
        tya  
        asl
        asl
        asl
        asl
        ora #$0A
        sta cards,Y
	
        
        
        jmp card_pick_end_no_action
        
monster_killed
	jsr count_card_usage
        lda #empty_card
        sta cards,Y

	jsr replace_hand_flash
        
        jmp card_pick_end_no_action
        
attack_player
	sta temp
	lda cards+4 
        and #$0F
        sec
        sbc temp
        bmi player_death
        beq player_death
        ora #player_type
        sta cards+4
        jmp card_pick_end_no_action
        

player_death
	; TODO
        lda #empty_card
        sta cards+4
        lda #$03
        sta gamestate
        jmp end_button

potion_heal_from_sector_zero
	lda #empty_card
        sta cards,X
        jmp potion_heal
potion_heal_sector_one
	lda #backpack_card
        sta cards+7
potion_heal
	lda temp
        and #$0F
        sta temp
        lda cards+4	; Player
        and #$0F
	clc
        adc temp
        cmp #$0a
        ora #$40
        sta cards+4
        bcc card_pick_end_no_action
        lda #$49
        sta cards+4
        jmp card_pick_end_no_action

card_place			    ; Move selection to location
	ldx flashindex
        ldy underlineindex
        lda cards,X
        sta temp
        ;potion check
        and #$F0
        cmp #$10
        bne rest_of_card_place
        cpy #$07	; Backpack
        bne potion_heal_from_sector_zero

rest_of_card_place
        lda temp
        sta cards,Y

card_place_replace
        lda #empty_card
        sta cards,X
        
card_pick_end_no_action

        lda #$00
        sta gamestate
        
        lda #$08
        sta flashindex
        
        ; END STATE ONE
        
        ; END GAME LOGIC
        
        jmp end_button
no_push_button
	lda #$00
        sta buttonstate
        ; Room Check (do it here for time)
        ldy #$00
       	ldx #$05
rc_loop
	dex
        
        lda cards,X
        cmp #empty_card
        bne rc_loop_end
	iny
rc_loop_end
        cpx #$00
        bne rc_loop
        
        cpy #$03
        bne end_button
        jsr new_room
        
end_button

	; End frame stuff
        lda framecounter
        clc 
        adc #$01
        sta framecounter
	
        
        TIMER_WAIT	; End Vblank

        jmp new_frame
        
        
; replace_hand
replace_hand_flash
	ldx flashindex
        cpx #$05
        beq replace_left_flash
        
        lda #right_hand_card
        sta cards,X
        
        jmp rh_end_flash
replace_left_flash

        lda #left_hand_card
        sta cards,X

rh_end_flash
        rts
        
; replace_hand
replace_hand_underline
	ldx underlineindex
        cpx #$05
        beq replace_left_underline
        
        lda #right_hand_card
        sta cards,X
        
        jmp rh_end_underline
replace_left_underline

        lda #left_hand_card
        sta cards,X

rh_end_underline
        rts
        
; do_joystick
do_joystick
        ; Controller stuff
        ldx #$00
        lda underlineindex
        cmp #$04
        bcc skip_sector_one
        ldx #$04
skip_sector_one
        
        
        lda SWCHA
        and #$80
        bne skip_right
        txa
        clc
        adc #$02
        sta underlineindex
skip_right
	lda SWCHA
        and #$40
        bne skip_left
        txa
        clc
        adc #$01
        sta underlineindex
skip_left


	lda SWCHA
        and #$20
        bne no_joy_down
        
        lda joydownstate
        bne end_joy_down
        
        lda #$01
        sta joydownstate
        
        lda underlineindex
        cmp #$03
        bne skip_joy_down_at_three
        
        lda #$04
        sta underlineindex
        jmp end_joy_down

skip_joy_down_at_three
	
        txa
        clc
        adc #$03
        sta underlineindex
	
        jmp end_joy_down
no_joy_down
	lda #$00
        sta joydownstate
end_joy_down


	lda SWCHA
        and #$10
        bne no_joy_up
        
        lda joyupstate
        bne end_joy_up
        
        lda #$01
        sta joyupstate
        
        lda underlineindex
        cmp #$04
        bne skip_joy_up_at_four
        
        lda #$03
        sta underlineindex
        jmp end_joy_up

skip_joy_up_at_four
	
        txa
        clc
        adc #$00
        sta underlineindex
	
        jmp end_joy_up
no_joy_up
	lda #$00
        sta joyupstate
end_joy_up
        
        
        rts

; put_cards_back
put_cards_back
	ldy deckindex
        ldx #$04
pc_loop
       	dex 
        iny
        cmp #(deck_len - 1)
        bne pc_cont
        ldy #$00
pc_cont
	lda cards,X
        sta deck,Y
        cpx #$00
        bne pc_loop
        
        
        
        lda #empty_card
        sta cards+0
        sta cards+1
        sta cards+2
        sta cards+3
        rts

; new_room
new_room
	ldx #$05
nr_loop
	dex
        
        lda cards,X
        cmp #empty_card
        bne nr_loop_end
        ldy deckindex
nr_loop_retry
        lda deck,Y
        cmp #$00
        bne nr_loop_cont
        dey
	bne nr_loop_retry_skip
        ldy #deck_len
nr_loop_retry_skip
        jmp nr_loop_retry

nr_loop_cont
        sta cards,X
        lda #$00
        sta deck,Y
        
        dey
        sty deckindex
        bpl nr_loop_end
        ldy #deck_len
        dey
        sty deckindex

nr_loop_end
        cpx #$00
        bne nr_loop
        
        lda #$04
        sta cardsinplay
        rts
        
; count_card_usage
count_card_usage
	ldx cardsinplay
        dex
        stx cardsinplay
        lda cardsleft
        and #$0F
        cmp #$00
        bne dec_cards_left
        lda cardsleft
        sec
        sbc #$07 
        sta cardsleft
        rts
        
dec_cards_left
	ldx cardsleft
        dex 
        stx cardsleft
        rts

; fillcard_a
; A = card index
; Fills cardasprite with the card index
fill_card_a
	sta temp3
        ldx #07
	; Flashing stuff
	cmp flashindex
        bne fill_card_a_loop
        lda #$10
        and framecounter
        beq fill_card_a_loop
        lda #$08
        sta temp3
        
        ;ldx #$07
fill_card_a_loop	; Loop over the 7 lines in the sprite
	dex

	txa
	sta temp
        clc
        ldy temp3	; Add current scanline to index
	adc cardindxt,y
        tay
        lda icon_types,y	; Get type bitmap
        sta temp2
        lda temp
        ldy temp3
        clc
        adc cardindxn,y
        tay
        lda temp2
        ora icon_numbers,y	; Combinde type and number bitmap
        sta cardasprite,x	; Store in current sprite
        
        cpx #$00
        bne fill_card_a_loop
        
        ldx temp3
        lda cardindxc,X
        sta cardacolor
        rts

; fillcard_b
; A = card index number
; Fills cardbsprite with the card index
fill_card_b
	sta temp3
        ldx #$07
       	; Flashing stuff
	cmp flashindex
        bne fill_card_b_loop
        lda #$10
        and framecounter
        beq fill_card_b_loop
        lda #$08
        sta temp3
fill_card_b_loop	; Loop over the 7 lines in the sprite
	dex

	txa
	sta temp
        clc
        ldy temp3	; Add current scanline to index
	adc cardindxt,y
        tay
        lda icon_types,y	; Get type bitmap
        sta temp2
        lda temp
        ldy temp3
        clc
        adc cardindxn,y	
        tay
        lda temp2
        ora icon_numbers,y	; Combinde type and number bitmap
        sta cardbsprite,x	; Store in current sprite
        
        cpx #$00
        bne fill_card_b_loop
        
        ldx temp3
        lda cardindxc,X
        sta cardbcolor
        rts
  
; print_card_a
; print cardasprite to screen
print_card_a
        ldx #$07		; 7 scanlines
sprite_loop_a
	dex
	lda cardasprite,x	; Load A sprite data
        sta WSYNC	
        sta GRP0		; Write to sprite register

        lda cardacolor
        sta COLUP0		; Set color
        
        cpx #$00
        bne sprite_loop_a
        

        lda #$00
        sta WSYNC	
        sta GRP0		; Clear sprite register
        rts

; print_card_ab
; print cardasprite and cardbsprite to screen
print_card_ab
        ldx #$07	
sprite_loop_ab			; 7 scanlines
	dex
	lda cardasprite,x	; Load A sprite data
        ldy cardbsprite,x	; Load B sprite data
        sta WSYNC
        sta GRP0		; Write to sprite registers
        sty GRP1

        lda cardacolor
        sta COLUP0		; Set colors
        lda cardbcolor
        sta COLUP1
        
        cpx #$00
        bne sprite_loop_ab
        

        lda #$00
        sta WSYNC
        sta GRP0		; Clear sprite data
        sta GRP1
        rts
        
; print_underline
print_underline
        lda #underline_color
        sta COLUP0
        
        sta WSYNC
        lda #$02
        sta ENAM0
        
        sta WSYNC
        sta WSYNC
        lda #$00
        sta ENAM0
	
        rts
        
; mult7
; A = A * 7
mult7
	tay
        lda #$00
        cpy #$00
        bne m7_loop
        rts
m7_loop
	clc
	adc #$07
        dey
        bne m7_loop
        rts
        
; mult5
; A = A * 5
mult5
	tay
        lda #$00
        cpy #$00
        bne m5_loop
        rts
m5_loop
	clc
	adc #$05
        dey
        bne m5_loop
        rts
        
; fill_cards
; Converts cards array to cardinxt and cardinxn
fill_cards
	ldx #cards_len	; 8 cards
fc_loop
	dex
	lda cards,x	; Load card index
        lsr		; Get high 4 bites
        lsr
        lsr
        lsr
        sta temp
        tay
        lda icon_colors,Y
        sta cardindxc,X
        lda temp
        ;stx temp
        jsr mult7	; Each sprite is 7 bytes
        ;ldx temp	; so multiply each index by 7
	sta cardindxt,x	; Store actual offset for type

        lda cards,x
        and #$0F	; Get the low 4 bites
        ;stx temp
        jsr mult7	; See above
        ;ldx temp
	sta cardindxn,x	; Store actual offset for number
        cpx #$00
        bne fc_loop
        rts
        
; fill_deck
; Copy preset deck to memory
fill_deck
	ldx #deck_len
fd_loop
	dex
	lda deck_start_layout,x
        sta deck,x
        cpx #$00
        bne fd_loop
        
        rts
        
; shuffle_deck
; Shuffles the values in our deck around
; Very slow, but very simple
shuffle_deck
	ldx #$FF	; Loop 255 times
sd_loop
	txa
        pha
	;stx temp3
        
	jsr rand
        ldx #deck_len
        jsr modulo	; Offset one
        pha		

        jsr rand
        ldx #deck_len
        jsr modulo	; Offset two
        tay 
        lda deck,y	; Load card at offset two
        sta temp
        
        pla 
        tax 
        lda deck,x	; Load card at offset one
        pha
        lda temp	; Load card two
        sta deck,x	; Store card two at offset one
        pla
        sta deck,y	; Store card one at offset two
        
        pla
        tax
        dex
        bne sd_loop
        rts
        
; mod
; A = A % X
modulo
	stx temp
m_loop
	cmp temp
        bcc m_end
        sbc temp
        jmp m_loop
m_end
	rts

; Rand
; Return and step the seed
; A = random number
; https://github.com/bbbradsmith/prng_6502/blob/master/galois16.s
rand
	ldy #8
	lda seed+0
r_loop
	asl        ; shift the register
	rol seed+1
	bcc r_skip
	eor #$39   ; apply XOR feedback whenever a 1 bit is shifted out
r_skip
	dey
	bne r_loop
	sta seed+0
	cmp #0     ; reload flags
	rts
        
; icons
icon_colors
	.byte #$22 ; Sword
        .byte #$52 ; Potion
        .byte #$C2 ; Sheild
        .byte #$42 ; Enemy
        .byte #$F2 ; Player
        .byte #$0E ; The rest
        .byte #$0E
        .byte #$0E
        .byte #$00
icon_types
icon_sword
	.byte #%01000000 
        .byte #%01000000
        .byte #%11100000
        .byte #%01000000
        .byte #%01000000
        .byte #%01000000
        .byte #%01000000
icon_potion
	.byte #%11100000 
        .byte #%10100000
        .byte #%10100000
        .byte #%10100000
        .byte #%11100000
        .byte #%01000000
        .byte #%01000000
icon_sheild
	.byte #%01000000 
        .byte #%00000000
        .byte #%10100000
        .byte #%10100000
        .byte #%10100000
        .byte #%00000000
        .byte #%01000000
icon_enemy
	.byte #%10100000 
        .byte #%10100000
        .byte #%11100000
        .byte #%01000000
        .byte #%00000000
        .byte #%10100000
        .byte #%10100000
icon_player
	.byte #%01000000 
        .byte #%10100000
        .byte #%01000000
        .byte #%10100000
        .byte #%01000000
        .byte #%10100000
        .byte #%01000000
icon_left
	.byte #%11100000 
        .byte #%11100000
        .byte #%10000000
        .byte #%10000000
        .byte #%10000000
        .byte #%10000000
        .byte #%10000000 
icon_right
	.byte #%10100000 
        .byte #%10100000
        .byte #%11000000
        .byte #%11000000
        .byte #%10100000
        .byte #%10100000
        .byte #%11000000
icon_backpack
	.byte #%11000000 
        .byte #%10100000
        .byte #%10100000
        .byte #%11000000
        .byte #%10100000
        .byte #%10100000
        .byte #%11000000
icon_x
	.byte #%10100000
        .byte #%10100000
        .byte #%01000000
        .byte #%01000000
        .byte #%01000000
        .byte #%10100000
        .byte #%10100000
icon_blank
	.byte #%00000000 
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000

        
icon_numbers
icon_zero
	.byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000101
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
icon_one
	.byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
icon_two
	.byte #%00000111
        .byte #%00000100
        .byte #%00000100
        .byte #%00000111
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111   
icon_three
	.byte #%00000111
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
icon_four
	.byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000101
icon_five
	.byte #%00000111
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000100
        .byte #%00000100
        .byte #%00000111
icon_six
	.byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
        .byte #%00000100
        .byte #%00000100
        .byte #%00000100
icon_seven
	.byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
icon_eight
	.byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
icon_nine
	.byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
icon_x2
	.byte #%00000101
        .byte #%00000101
        .byte #%00000010
        .byte #%00000010
        .byte #%00000010
        .byte #%00000101
        .byte #%00000101
icon_blank2
	.byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        .byte #%00000000
        
score_bitmap
	.byte #%00000111
        .byte #%00000101
        .byte #%00000101
        .byte #%00000101
        .byte #%00000111
     
	.byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        
        .byte #%00000111
        .byte #%00000100
        .byte #%00000111
        .byte #%00000001
        .byte #%00000111
        
        .byte #%00000111
        .byte #%00000001
        .byte #%00000011
        .byte #%00000001
        .byte #%00000111
        
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000101
        .byte #%00000101
        
        .byte #%00000111
        .byte #%00000001
        .byte #%00000111
        .byte #%00000100
        .byte #%00000111
        
        .byte #%00000111
        .byte #%00000101
        .byte #%00000111
        .byte #%00000100
        .byte #%00000100
        
        .byte #%00000001
        .byte #%00000001
        .byte #%00000001
        .byte #%00000101
        .byte #%00000111
        
        .byte #%00000111
        .byte #%00000101
        .byte #%00000111
        .byte #%00000101
        .byte #%00000111
        
        .byte #%00000001
        .byte #%00000001
        .byte #%00000111
        .byte #%00000101
        .byte #%00000111
        
deck_start_layout
	HEX 01 02 03 04 05 06 07 08 09
        HEX 11 12 13 14 15 16 17 18 19
        HEX 21 22 23 24 25 26 27 28 29
        HEX 31 32 33 34 35 35 36 36 36
        HEX 37 37 37 38 38 38 39 39 39
     
     
; Vectors
	org $FFFC
        .word init	; reset vector
        .word init	; BRK vector
